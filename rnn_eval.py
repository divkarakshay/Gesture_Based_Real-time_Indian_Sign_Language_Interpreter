"""
Run a holdout set of data through our trained RNN. Requires we first
run train_rnn.py and save the weights.
"""
from rnn_utils import get_network_wide, get_data
import argparse
import tensorflow as tf
import tflearn
import numpy as np
import sys
import os
import pandas as pd
from pdb import set_trace

def load_labels(label_file):
    label = {}
    count = 0
    proto_as_ascii_lines = tf.io.gfile.GFile(label_file).readlines()
    for l in proto_as_ascii_lines:
        label[l.strip()] = count
        count += 1
    return label


def evaluate(input_data_dump, num_frames_per_video, batch_size, labels, model_file):
    
    
    # mloc = os.getcwd()
    # input_data_dump = pd.read_pickle(mloc + '\\predicted-frames-GlobalPool-train.pkl')
    # num_frames_per_video = 201
    # labels = "retrained_labels.txt"

    # # Get our data.
    #print(input_data_dump[0])
    X, Y = get_data(input_data_dump, num_frames_per_video, labels, False)
    print(X)
    num_classes = len(labels)
    if len(X.shape) == 2:
        size_of_each_frame = 1
    else:
        size_of_each_frame = X.shape[2]

    # Get our network.
    net = get_network_wide(num_frames_per_video, size_of_each_frame, num_classes)

    # Train the model.
    model = tflearn.DNN(net, tensorboard_verbose=0)
    try:
        model.load('checkpoints/' + model_file)
        print("\nModel Exists! Loading it")
        print("Model Loaded")
    except Exception:
        print("\nNo previous checkpoints of %s exist" % (model_file))
        print("Exiting..")
        sys.exit()

    predictions = model.predict(X)
    predictions = np.array([np.argmax(pred) for pred in predictions])
    print("Output :", predictions)
    rev_labels = dict(zip(list(labels.values()), list(labels.keys())))
    print(rev_labels, predictions)
    for a,b in enumerate(predictions):
            print(a, rev_labels[b])
    return predictions
    # Y = np.array([np.argmax(each) for each in Y])
    #added
    
    # Writing predictions and gold labels to file
    # with open("result.txt", "w") as f:
    #     f.write("gold, pred\n")
    #     for a, b in zip(Y, predictions):
    #         f.write("%s %s\n" % (rev_labels[a], rev_labels[b]))
    #         print(rev_labels[a], rev_labels[b])
    #added
    #print(X)

    # acc = 100 * np.sum(predictions == Y) / len(Y)
    # print("Accuracy: ", acc)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Test the RNN model')
    parser.add_argument("input_file_dump", help="file containing intermediate representation of gestures from inception model.")
    parser.add_argument("model_file", help="Name of the model file to be used for prediction.")
    parser.add_argument("--label_file", help="path to label file generated by inception", default="retrained_labels.txt")
    parser.add_argument("--batch_size", help="batch Size", default=10)
    args = parser.parse_args()

    labels = load_labels(args.label_file)
    input_data_dump = args.input_file_dump
    num_frames_per_video = 10
    batch_size = args.batch_size
    model_file = args.model_file

    evaluate(input_data_dump, num_frames_per_video, batch_size, labels, model_file)
